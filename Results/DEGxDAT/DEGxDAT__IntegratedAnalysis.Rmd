---
title: "Integrated Host Transcriptome-Microbiome Analysis"
author: "Michael Sieler"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    cache: true
    cache.lazy: true
    cache.comments: false
    cache.rebuild: false
---

# Script Overview

This script performs an integrated analysis of host gene expression (DEGs) and microbial abundance (DATs) to identify potential interactions between the host transcriptome and microbiome. The analysis focuses on:

1. Identifying differentially expressed genes (DEGs) in the host
2. Identifying differentially abundant taxa (DATs) in the microbiome
3. Analyzing correlations between DEGs and DATs
4. Creating a bipartite network visualization of host-microbiome interactions
5. Performing functional enrichment analysis of correlated genes

**Input:**
- Differentially expressed genes: `/Users/michaelsieler/Dropbox/Mac (2)/Documents/Sharpton_Lab/Projects_Repository/Rules_of_Life/major-experiment-2023/Code/Analysis/DiffExpGene/Results`
- Differentially abundant taxa: `/Users/michaelsieler/Dropbox/Mac (2)/Documents/Sharpton_Lab/Projects_Repository/Rules_of_Life/major-experiment-2023/Code/Analysis/DiffAbund/Results`
- Phyloseq object: `ps.cleaned` (must be loaded in environment)
- Gene expression data: `normalized_counts.tsv`
- Metadata: `sample_metadata__2025-05-19.tsv`

**Output:**
- Integrated tables, correlation results, bipartite network plots, and functional enrichment summaries.

**Note:** This script extracts OTU table data directly from the phyloseq object (`ps.cleaned`) and filters samples based on the specific analysis being performed. The phyloseq object must be loaded before running this script.

---

## Setup {.tabset}

### Libraries

```{r setup, message=FALSE, warning=FALSE}
set.seed(42)

library(gt)
library(pheatmap)
library(ggrepel)
library(igraph)
library(tidygraph)
library(ggraph)
library(DESeq2)
library(phyloseq)
library(microViz)
library(vegan)
library(RColorBrewer)
library(ggpubr)
library(org.Dr.eg.db)
library(ppcor)
library(GO.db)
library(AnnotationDbi)
library(KEGGREST)
library(tidyverse)
```

### Functions

```{r correlation_functions}


# Function to extract sample data as dataframe from phyloseq object
samdatAsDataframe <- function(ps) {
  samdat <- phyloseq::sample_data(ps)
  df <- data.frame(samdat, check.names = FALSE, stringsAsFactors = FALSE)
  return(df)
}

# Function to rename variables in phyloseq object
ps_rename <- function(ps, ...) {
  ps <- microViz::ps_get(ps)
  df <- samdatAsDataframe(ps)
  df <- dplyr::rename(.data = df, ...)
  phyloseq::sample_data(ps) <- df
  return(ps)
}

# SourceFolder function
source(here::here("Code", "R", "Functions", "StartFunctions", "sourceFolder.R"))

# Import all helper functions found in `/Functions`
sourceFolder(here::here("Code", "R", "Functions", "StartFunctions"), T)
sourceFolder(here::here("Code", "R", "Functions", "HelperFunctions"), T)
# sourceFolder(here::here("Code", "R", "Functions", "AnalysisScripts"), T)


# --- Modular Functions for DEG-DAT Correlation Analysis ---

# Function to check and fix taxa ID mapping
check_taxa_mapping <- function(ps_object, dat_sig) {
  cat("Checking taxa ID mapping between phyloseq and DAT results...\n")
  
  # Get taxonomy table from phyloseq
  tax_table <- ps_object %>%
    microViz::ps_get() %>%
    tax_table() %>%
    as.data.frame() %>%
    rownames_to_column(var = "ASV_ID")
  
  cat("Taxonomy table dimensions:", nrow(tax_table), "ASVs\n")
  cat("Taxonomy columns:", paste(colnames(tax_table), collapse = ", "), "\n")
  
  # Check if Genus column exists
  if ("Genus" %in% colnames(tax_table)) {
    cat("Genus column found in taxonomy table\n")
    cat("Number of unique genera:", length(unique(tax_table$Genus)), "\n")
    cat("Sample genera:", paste(head(unique(tax_table$Genus), 5), collapse = ", "), "\n")
    
    # Check overlap with DAT results
    dat_genera <- unique(dat_sig$feature)
    phylo_genera <- unique(tax_table$Genus)
    
    cat("Number of genera in DAT results:", length(dat_genera), "\n")
    cat("Number of genera in phyloseq:", length(phylo_genera), "\n")
    cat("Number of matching genera:", length(intersect(dat_genera, phylo_genera)), "\n")
    
    # Show some examples
    matching_genera <- intersect(dat_genera, phylo_genera)
    non_matching_dat <- setdiff(dat_genera, phylo_genera)
    non_matching_phylo <- setdiff(phylo_genera, dat_genera)
    
    cat("Sample matching genera:", paste(head(matching_genera, 5), collapse = ", "), "\n")
    cat("Sample DAT genera not in phyloseq:", paste(head(non_matching_dat, 5), collapse = ", "), "\n")
    cat("Sample phyloseq genera not in DAT:", paste(head(non_matching_phylo, 5), collapse = ", "), "\n")
    
    return(list(
      tax_table = tax_table,
      matching_genera = matching_genera,
      can_map = length(matching_genera) > 0
    ))
  } else {
    cat("No Genus column found in taxonomy table\n")
    return(list(can_map = FALSE))
  }
}

# Function 1: Import and prepare data for correlation analysis
prepare_correlation_data <- function(deg_sig, dat_sig, 
                                   expr_file = here::here("Code", "Analysis", "DiffExpGene", "Results", "normalized_counts.tsv"),
                                   treatments = NULL,  # Vector of treatments to filter for
                                   ps_object = ps.cleaned,  # Phyloseq object
                                   meta_file = here::here("Code", "Analysis", "DiffExpGene", "Results", "sample_metadata.tsv")) {
  
  # Import gene expression data
  expr_norm <- readr::read_tsv(expr_file)
  cat("Expression data dimensions:", nrow(expr_norm), "genes x", ncol(expr_norm)-1, "samples\n")
  cat("Expression data columns:", paste(colnames(expr_norm)[1:5], collapse = ", "), "...\n")
  
  # Extract OTU table from phyloseq object and filter by treatments
  if (!is.null(treatments)) {
    ps_filtered <- ps_object %>%
      microViz::ps_filter(Treatment %in% treatments)
    cat("Filtered phyloseq to treatments:", paste(treatments, collapse = ", "), "\n")
  } else {
    ps_filtered <- ps_object
    cat("Using all treatments from phyloseq object\n")
  }
  
  # Check taxa mapping first
  taxa_mapping <- check_taxa_mapping(ps_filtered, dat_sig)
  
  # Extract OTU table and convert to data frame
  otu_norm <- ps_filtered %>%
    microViz::ps_get() %>%
    otu_table() %>%
    as.data.frame() %>%
    rownames_to_column(var = "TaxaID") %>%
    dplyr::rename_with(
      ~ stringr::str_remove(., "^f"),
      .cols = -TaxaID  # Exclude the "Sample" column
    )
  
  cat("OTU table dimensions:", nrow(otu_norm), "ASVs x", ncol(otu_norm)-1, "Samples\n")
  cat("First few OTU taxa IDs:", paste(colnames(otu_norm)[2:6], collapse = ", "), "...\n")
  
  # Import metadata that matches expression data sample names
  metadata <- readr::read_tsv(meta_file)
  cat("Metadata dimensions:", nrow(metadata), "samples x", ncol(metadata), "variables\n")
  
  # Convert sample names to match between datasets
  # Expression data uses sample names like "110", "112", etc.
  # Metadata uses sample names like "110", "112", etc. (same format)
  # Phyloseq object uses sample names like "f1", "f2", etc.
  
  # Create a mapping from phyloseq sample names to expression sample names
  # This mapping should be based on the fecal.sample.number in the phyloseq object
  ps_sample_data <- ps_filtered %>%
    microViz::samdat_tbl() %>%
    dplyr::select(Sample, fecal.sample.number) %>%
    dplyr::mutate(
      # Extract the number from fecal.sample.number (e.g., "f106" -> "106")
      expr_sample_name = gsub("^f", "", fecal.sample.number)
    )
  
  cat("Phyloseq sample mapping created for", nrow(ps_sample_data), "samples\n")
  cat("First few mapped samples:", paste(head(ps_sample_data$expr_sample_name, 5), collapse = ", "), "\n")
  
  # Filter metadata to match the samples in the filtered phyloseq object
  filtered_samples <- ps_sample_data$expr_sample_name
  metadata_filtered <- metadata %>%
    dplyr::filter(sample %in% filtered_samples) %>%
    dplyr::mutate(Sample = as.character(sample)) %>%  # Ensure Sample is character
    dplyr::select(-sample)  # Remove the original sample column
  
  cat("Filtered metadata dimensions:", nrow(metadata_filtered), "samples\n")
  
  # Tidy gene expression: long format (Sample, gene, expr)
  expr_long <- expr_norm %>%
    tidyr::pivot_longer(-gene, names_to = "Sample", values_to = "expr") %>%
    dplyr::rename(gene_id = gene) %>%  # Rename to match expected column name
    dplyr::mutate(Sample = as.character(Sample))  # Ensure Sample is character
  
  # Tidy taxa: long format (Sample, TaxaID, abundance)
  # Need to map phyloseq sample names to expression sample names
  otu_long <- otu_norm %>%
    tidyr::pivot_longer(-TaxaID, names_to = "Sample", values_to = "abundance") %>%
    dplyr::left_join(ps_sample_data, by = "Sample") %>%
    dplyr::select(-Sample, -fecal.sample.number) %>%
    dplyr::rename(Sample = expr_sample_name) %>%
    dplyr::mutate(Sample = as.character(Sample))  # Ensure Sample is character
  
  # If we can map ASV IDs to genus names, do it
  if (taxa_mapping$can_map) {
    cat("Mapping ASV IDs to genus names...\n")
    otu_long <- otu_long %>%
      dplyr::left_join(taxa_mapping$tax_table %>% dplyr::select(ASV_ID, Genus), 
                      by = c("TaxaID" = "ASV_ID")) %>%
      dplyr::mutate(TaxaID = Genus) %>%
      dplyr::select(-Genus) %>%
      dplyr::filter(!is.na(TaxaID))  # Filter out NA values after mapping
  }
  
  # Check taxa ID matching
  cat("DAT taxa IDs (first 5):", paste(head(dat_sig$feature, 5), collapse = ", "), "\n")
  cat("OTU taxa IDs (first 5):", paste(head(unique(otu_long$TaxaID), 5), collapse = ", "), "\n")
  
  # Debug: Check for NA values in key columns
  cat("Debug: NA values in key columns after mapping:\n")
  cat("NA in otu_long$TaxaID:", sum(is.na(otu_long$TaxaID)), "\n")
  cat("NA in otu_long$Sample:", sum(is.na(otu_long$Sample)), "\n")
  cat("NA in expr_long$gene_id:", sum(is.na(expr_long$gene_id)), "\n")
  cat("NA in expr_long$Sample:", sum(is.na(expr_long$Sample)), "\n")
  
  # Filter to significant DEGs and DATs
  expr_long_filt <- expr_long %>% dplyr::filter(gene_id %in% deg_sig$gene)
  otu_long_filt <- otu_long %>% dplyr::filter(TaxaID %in% dat_sig$feature)
  
  cat("After filtering - DEGs:", length(unique(deg_sig$gene)), "genes\n")
  cat("After filtering - DATs:", length(unique(dat_sig$feature)), "taxa\n")
  cat("Expression data after filtering:", nrow(expr_long_filt), "rows\n")
  cat("OTU data after filtering:", nrow(otu_long_filt), "rows\n")
  
  # Debug: Check for NA values after filtering
  cat("Debug: NA values after filtering:\n")
  cat("NA in expr_long_filt$gene_id:", sum(is.na(expr_long_filt$gene_id)), "\n")
  cat("NA in otu_long_filt$TaxaID:", sum(is.na(otu_long_filt$TaxaID)), "\n")
  
  # If no OTU data after filtering, try to understand why
  if (nrow(otu_long_filt) == 0) {
    cat("WARNING: No OTU data after filtering. Checking taxa ID matching:\n")
    cat("Number of unique taxa in OTU data:", length(unique(otu_long$TaxaID)), "\n")
    cat("Number of unique taxa in DAT results:", length(unique(dat_sig$feature)), "\n")
    cat("Number of matching taxa:", length(intersect(unique(otu_long$TaxaID), unique(dat_sig$feature))), "\n")
    
    # Show some examples of non-matching taxa
    otu_taxa <- unique(otu_long$TaxaID)
    dat_taxa <- unique(dat_sig$feature)
    non_matching_otu <- setdiff(otu_taxa, dat_taxa)
    non_matching_dat <- setdiff(dat_taxa, otu_taxa)
    
    cat("Sample OTU taxa not in DAT results:", paste(head(non_matching_otu, 5), collapse = ", "), "\n")
    cat("Sample DAT taxa not in OTU data:", paste(head(non_matching_dat, 5), collapse = ", "), "\n")
  }
  
  # Join by Sample for all DEG-DAT pairs
  cor_input <- expr_long_filt %>%
    dplyr::inner_join(otu_long_filt, by = "Sample")
  
  cat("Final correlation input:", nrow(cor_input), "gene-taxa pairs\n")
  cat("Unique samples in correlation data:", length(unique(cor_input$Sample)), "\n")
  
  # Debug: Final check for NA values
  cat("Debug: Final NA values in cor_input:\n")
  cat("NA in cor_input$gene_id:", sum(is.na(cor_input$gene_id)), "\n")
  cat("NA in cor_input$TaxaID:", sum(is.na(cor_input$TaxaID)), "\n")
  cat("NA in cor_input$Sample:", sum(is.na(cor_input$Sample)), "\n")
  
  # Add metadata covariates
  cor_input_cov <- cor_input %>%
    dplyr::left_join(metadata_filtered %>% dplyr::select(Sample, Total.Worm.Count), by = "Sample")
  
  return(list(
    cor_input = cor_input,
    cor_input_cov = cor_input_cov,
    metadata = metadata_filtered,
    n_deg = length(unique(deg_sig$gene)),
    n_dat = length(unique(dat_sig$feature)),
    n_samples = length(unique(cor_input$Sample)),
    treatments_used = treatments
  ))
}

# Function 2: Calculate simple correlations
calculate_simple_correlations <- function(cor_input, method = "spearman") {
  
  # Safety check: filter out NA values
  cor_input_clean <- cor_input %>%
    dplyr::filter(!is.na(gene_id), !is.na(TaxaID), !is.na(expr), !is.na(abundance))
  
  if (nrow(cor_input_clean) == 0) {
    cat("No valid data after filtering NA values in calculate_simple_correlations\n")
    return(NULL)
  }
  
  cat("Debug: calculate_simple_correlations - rows after NA filtering:", nrow(cor_input_clean), "\n")
  
  # Calculate correlation for each gene-taxa pair
  cor_results <- cor_input_clean %>%
    dplyr::group_by(gene_id, TaxaID) %>%
    dplyr::summarise(
      cor = cor(expr, abundance, method = method, use = "pairwise.complete.obs"),
      n = dplyr::n(),
      .groups = "drop"
    ) %>%
    dplyr::mutate(abs_cor = abs(cor)) %>%
    dplyr::arrange(desc(abs_cor))
  
  return(cor_results)
}

# Function 3: Calculate partial correlations
calculate_partial_correlations <- function(cor_input_cov, top_n = 50, 
                                         covariate = "Total.Worm.Count", 
                                         method = "spearman") {
  
  # Install ppcor if needed
  if (!requireNamespace("ppcor", quietly = TRUE)) {
    install.packages("ppcor")
  }
  
  
  # Get top pairs from simple correlation
  top_pairs <- cor_input_cov %>%
    dplyr::group_by(gene_id, TaxaID) %>%
    dplyr::summarise(
      cor = cor(expr, abundance, method = method, use = "pairwise.complete.obs"),
      .groups = "drop"
    ) %>%
    dplyr::mutate(abs_cor = abs(cor)) %>%
    dplyr::arrange(desc(abs_cor)) %>%
    dplyr::slice_head(n = top_n)
  
  # Calculate partial correlation for top pairs
  partial_cor_results <- purrr::map_dfr(1:nrow(top_pairs), function(i) {
    g <- top_pairs$gene_id[i]
    t <- top_pairs$TaxaID[i]
    dat <- cor_input_cov %>% dplyr::filter(gene_id == g, TaxaID == t)
    
    if (nrow(dat) < 5) return(NULL)
    
    res <- tryCatch({
      pcor.test(dat$expr, dat$abundance, dat[[covariate]], method = method)
    }, error = function(e) NULL)
    
    if (is.null(res)) return(NULL)
    
    tibble::tibble(
      gene_id = g,
      TaxaID = t,
      partial_cor = res$estimate,
      p.value = res$p.value,
      n = nrow(dat)
    )
  })
  
  # Adjust p-values
  partial_cor_results <- partial_cor_results %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH")) %>%
    dplyr::arrange(desc(abs(partial_cor)))
  
  return(partial_cor_results)
}

# Function 4: Create correlation summary plots
plot_correlation_summary <- function(cor_results, partial_cor_results = NULL, 
                                   section_name = "Analysis") {
  
  # Simple correlation histogram
  p1 <- cor_results %>%
    ggplot(aes(x = cor)) +
    geom_histogram(bins = 50, fill = "steelblue", color = "black") +
    theme_minimal() +
    labs(title = paste("Distribution of DEG-DAT Correlations -", section_name),
         x = "Spearman Correlation", y = "Count")
  
  plots <- list(simple_cor = p1)
  
  # Partial correlation histogram (if provided)
  if (!is.null(partial_cor_results) && nrow(partial_cor_results) > 0) {
    p2 <- partial_cor_results %>%
      ggplot(aes(x = partial_cor)) +
      geom_histogram(bins = 30, fill = "orange", color = "black") +
      theme_minimal() +
      labs(title = paste("Distribution of Partial Correlations -", section_name),
           x = "Partial Spearman Correlation", y = "Count")
    
    plots$partial_cor <- p2
  }
  
  return(plots)
}

# Function 5: Print correlation summary statistics
print_correlation_summary <- function(cor_results, partial_cor_results = NULL, 
                                    section_name = "Analysis") {
  
  cat("\n=== Correlation Summary for", section_name, "===\n")
  cat("Number of gene-taxa pairs:", nrow(cor_results), "\n")
  cat("Number of samples:", length(unique(cor_results$n)), "\n")
  
  cat("\nSimple Correlation Summary (Spearman):\n")
  print(summary(cor_results$cor))
  
  cat("\nTop 10 strongest correlations:\n")
  print(cor_results %>% dplyr::slice_max(abs_cor, n = 10))
  
  if (!is.null(partial_cor_results) && nrow(partial_cor_results) > 0) {
    cat("\nPartial Correlation Summary (controlling for worm count):\n")
    print(summary(partial_cor_results$partial_cor))
    
    cat("\nTop 10 strongest partial correlations:\n")
    print(partial_cor_results %>% dplyr::slice_max(abs(partial_cor), n = 10))
  }
}

# Function 6: Create bipartite network visualization
create_bipartite_network <- function(cor_results, partial_cor_results = NULL,
                                   cor_threshold = 0.5, p_threshold = 0.05,
                                   max_edges = 100, section_name = "Analysis") {
  
  # Determine which correlation results to use
  if (!is.null(partial_cor_results) && nrow(partial_cor_results) > 0) {
    # Use partial correlations if available
    sig_edges <- partial_cor_results %>%
      dplyr::filter(abs(partial_cor) >= cor_threshold, fdr <= p_threshold) %>%
      dplyr::slice_max(abs(partial_cor), n = max_edges) %>%
      dplyr::mutate(
        correlation = partial_cor,
        edge_type = "partial"
      )
  } else {
    # Use simple correlations
    sig_edges <- cor_results %>%
      dplyr::filter(abs_cor >= cor_threshold) %>%
      dplyr::slice_max(abs_cor, n = max_edges) %>%
      dplyr::mutate(
        correlation = cor,
        edge_type = "simple"
      )
  }
  
  if (nrow(sig_edges) == 0) {
    cat("No significant correlations found for network visualization.\n")
    return(NULL)
  }
  
  # Debug: Check for NA values
  cat("Debug: Checking for NA values in sig_edges...\n")
  cat("Total rows in sig_edges:", nrow(sig_edges), "\n")
  cat("NA values in gene_id:", sum(is.na(sig_edges$gene_id)), "\n")
  cat("NA values in TaxaID:", sum(is.na(sig_edges$TaxaID)), "\n")
  
  # Filter out NA values from gene_id and TaxaID columns
  sig_edges <- sig_edges %>%
    dplyr::filter(!is.na(gene_id), !is.na(TaxaID))
  
  if (nrow(sig_edges) == 0) {
    cat("No valid gene-taxa pairs found after filtering NA values.\n")
    return(NULL)
  }
  
  cat("Rows after filtering NA values:", nrow(sig_edges), "\n")
  
  # Create nodes
  gene_nodes <- sig_edges %>%
    dplyr::select(gene_id) %>%
    dplyr::distinct() %>%
    dplyr::filter(!is.na(gene_id)) %>%
    dplyr::mutate(
      id = gene_id,
      name = gene_id,
      type = "gene",
      node_type = "gene"
    )
  
  taxa_nodes <- sig_edges %>%
    dplyr::select(TaxaID) %>%
    dplyr::distinct() %>%
    dplyr::filter(!is.na(TaxaID)) %>%
    dplyr::mutate(
      id = TaxaID,
      name = TaxaID,
      type = "taxa",
      node_type = "taxa"
    )
  
  # Check if we have valid nodes
  if (nrow(gene_nodes) == 0 || nrow(taxa_nodes) == 0) {
    cat("No valid nodes found after filtering NA values.\n")
    cat("Gene nodes:", nrow(gene_nodes), "\n")
    cat("Taxa nodes:", nrow(taxa_nodes), "\n")
    return(NULL)
  }
  
  cat("Created", nrow(gene_nodes), "gene nodes and", nrow(taxa_nodes), "taxa nodes\n")
  
  # Create edges
  edges <- sig_edges %>%
    dplyr::select(from = gene_id, to = TaxaID, correlation, edge_type) %>%
    dplyr::filter(!is.na(from), !is.na(to)) %>%
    dplyr::mutate(
      weight = abs(correlation),
      direction = ifelse(correlation > 0, "positive", "negative")
    )
  
  if (nrow(edges) == 0) {
    cat("No valid edges found after filtering NA values.\n")
    return(NULL)
  }
  
  cat("Created", nrow(edges), "edges\n")
  
  # Create tidygraph
  nodes <- dplyr::bind_rows(gene_nodes, taxa_nodes)
  
  # Final check for NA values in nodes
  cat("Final check - NA values in node columns:\n")
  cat("NA in id:", sum(is.na(nodes$id)), "\n")
  cat("NA in name:", sum(is.na(nodes$name)), "\n")
  cat("NA in type:", sum(is.na(nodes$type)), "\n")
  cat("NA in node_type:", sum(is.na(nodes$node_type)), "\n")
  
  network <- tidygraph::tbl_graph(
    nodes = nodes,
    edges = edges,
    directed = FALSE
  )
  
  # Create network plot
  p <- ggraph::ggraph(network, layout = "bipartite") +
    ggraph::geom_edge_link(
      ggplot2::aes(color = correlation, alpha = weight),
      width = 1
    ) +
    ggraph::geom_node_point(
      ggplot2::aes(shape = node_type, size = node_type),
      color = "black"
    ) +
    ggraph::geom_node_text(
      ggplot2::aes(label = name),
      size = 3,
      repel = TRUE
    ) +
    ggplot2::scale_color_gradient2(
      low = "blue", mid = "white", high = "red",
      midpoint = 0,
      name = "Correlation"
    ) +
    ggplot2::scale_shape_manual(
      values = c(gene = 16, taxa = 17),
      name = "Node Type"
    ) +
    ggplot2::scale_size_manual(
      values = c(gene = 3, taxa = 4),
      name = "Node Type"
    ) +
    ggplot2::labs(
      title = paste("Bipartite Network -", section_name),
      subtitle = paste("Showing", nrow(sig_edges), "significant correlations")
    ) +
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.position = "bottom",
      plot.title = ggplot2::element_text(size = 14, face = "bold")
    )
  
  return(list(
    plot = p,
    network = network,
    edges = sig_edges,
    n_genes = nrow(gene_nodes),
    n_taxa = nrow(taxa_nodes),
    n_edges = nrow(sig_edges)
  ))
}

# Function 7: Map gene symbols to Entrez IDs
map_genes_to_entrez <- function(gene_list, organism = "org.Dr.eg.db") {
  
  # Check if organism database is available
  if (!requireNamespace(organism, quietly = TRUE)) {
    stop(paste("Organism database", organism, "is not available. Please install it."))
  }
  
  # Get the organism database
  org_db <- get(organism)
  
  # Map gene symbols to Entrez IDs
  entrez_mapping <- AnnotationDbi::mapIds(
    org_db,
    keys = gene_list,
    column = "ENTREZID",
    keytype = "SYMBOL",
    multiVals = "first"
  ) %>%
    tibble::enframe(name = "SYMBOL", value = "ENTREZID") %>%
    dplyr::filter(!is.na(ENTREZID)) %>%
    dplyr::distinct()
  
  cat("Successfully mapped", nrow(entrez_mapping), "out of", length(gene_list), "genes to Entrez IDs\n")
  
  return(entrez_mapping)
}

# Function 8: Run GO enrichment analysis
run_go_enrichment <- function(entrez_ids, background_entrez = NULL,
                            organism = "org.Dr.eg.db", 
                            pvalue_cutoff = 0.05, qvalue_cutoff = 0.2,
                            ont = "BP", section_name = "Analysis") {
  
  # Check if clusterProfiler is available
  if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
    install.packages("clusterProfiler")
  }
  library(clusterProfiler)
  
  # Get organism database
  org_db <- get(organism)
  
  # Run GO enrichment
  go_results <- clusterProfiler::enrichGO(
    gene = entrez_ids,
    OrgDb = org_db,
    keyType = "ENTREZID",
    ont = ont,
    pAdjustMethod = "BH",
    pvalueCutoff = pvalue_cutoff,
    qvalueCutoff = qvalue_cutoff,
    readable = TRUE
  )
  
  if (is.null(go_results) || nrow(go_results) == 0) {
    cat("No significant GO terms found for", section_name, "\n")
    return(NULL)
  }
  
  # Convert to data frame and add section info
  go_df <- as.data.frame(go_results) %>%
    dplyr::mutate(
      section = section_name,
      log_pvalue = -log10(pvalue),
      log_qvalue = -log10(p.adjust)
    ) %>%
    dplyr::arrange(p.adjust)
  
  cat("Found", nrow(go_df), "significant GO terms for", section_name, "\n")
  
  return(go_df)
}

# Function 9: Run KEGG enrichment analysis
run_kegg_enrichment <- function(entrez_ids, organism = "dre",
                              pvalue_cutoff = 0.05, qvalue_cutoff = 0.2,
                              section_name = "Analysis") {
  
  # Check if clusterProfiler is available
  if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
    install.packages("clusterProfiler")
  }
  library(clusterProfiler)
  
  # Run KEGG enrichment
  kegg_results <- clusterProfiler::enrichKEGG(
    gene = entrez_ids,
    organism = organism,
    keyType = "ncbi-geneid",
    pAdjustMethod = "BH",
    pvalueCutoff = pvalue_cutoff,
    qvalueCutoff = qvalue_cutoff
  )
  
  if (is.null(kegg_results) || nrow(kegg_results) == 0) {
    cat("No significant KEGG pathways found for", section_name, "\n")
    return(NULL)
  }
  
  # Convert to data frame and add section info
  kegg_df <- as.data.frame(kegg_results) %>%
    dplyr::mutate(
      section = section_name,
      log_pvalue = -log10(pvalue),
      log_qvalue = -log10(p.adjust)
    ) %>%
    dplyr::arrange(p.adjust)
  
  cat("Found", nrow(kegg_df), "significant KEGG pathways for", section_name, "\n")
  
  return(kegg_df)
}

# Function 10: Comprehensive functional enrichment analysis
run_functional_enrichment <- function(cor_results, partial_cor_results = NULL,
                                    cor_threshold = 0.5, p_threshold = 0.05,
                                    organism = "dre", section_name = "Analysis") {
  
  # Determine which correlation results to use
  if (!is.null(partial_cor_results) && nrow(partial_cor_results) > 0) {
    # Use partial correlations if available
    sig_genes <- partial_cor_results %>%
      dplyr::filter(abs(partial_cor) >= cor_threshold, fdr <= p_threshold) %>%
      dplyr::pull(gene_id) %>%
      unique()
  } else {
    # Use simple correlations
    sig_genes <- cor_results %>%
      dplyr::filter(abs_cor >= cor_threshold) %>%
      dplyr::pull(gene_id) %>%
      unique()
  }
  
  if (length(sig_genes) == 0) {
    cat("No significant genes found for functional enrichment in", section_name, "\n")
    return(NULL)
  }
  
  cat("Running functional enrichment for", length(sig_genes), "genes in", section_name, "\n")
  
  # Map genes to Entrez IDs
  entrez_mapping <- map_genes_to_entrez(sig_genes)
  
  if (nrow(entrez_mapping) == 0) {
    cat("No genes could be mapped to Entrez IDs for", section_name, "\n")
    return(NULL)
  }
  
  # Run GO enrichment
  go_results <- run_go_enrichment(
    entrez_mapping$ENTREZID,
    section_name = section_name
  )
  
  # Run KEGG enrichment
  kegg_results <- run_kegg_enrichment(
    entrez_mapping$ENTREZID,
    organism = organism,
    section_name = section_name
  )
  
  return(list(
    genes = sig_genes,
    entrez_mapping = entrez_mapping,
    go_results = go_results,
    kegg_results = kegg_results,
    n_genes = length(sig_genes),
    n_entrez = nrow(entrez_mapping)
  ))
}

# Function 11: Plot functional enrichment results
plot_enrichment_results <- function(enrichment_results, section_name = "Analysis") {
  
  plots <- list()
  
  # GO enrichment plot
  if (!is.null(enrichment_results$go_results) && nrow(enrichment_results$go_results) > 0) {
    go_plot <- enrichment_results$go_results %>%
      dplyr::slice_max(log_qvalue, n = 15) %>%
      ggplot(aes(x = reorder(Description, log_qvalue), y = log_qvalue, fill = Count)) +
      geom_col() +
      coord_flip() +
      scale_fill_viridis_c() +
      labs(
        title = paste("Top GO Terms -", section_name),
        x = "GO Term",
        y = "-log10(adjusted p-value)",
        fill = "Gene Count"
      ) +
      theme_minimal() +
      theme(axis.text.y = element_text(size = 10))
    
    plots$go_plot <- go_plot
  }
  
  # KEGG enrichment plot
  if (!is.null(enrichment_results$kegg_results) && nrow(enrichment_results$kegg_results) > 0) {
    kegg_plot <- enrichment_results$kegg_results %>%
      dplyr::slice_max(log_qvalue, n = 15) %>%
      ggplot(aes(x = reorder(Description, log_qvalue), y = log_qvalue, fill = Count)) +
      geom_col() +
      coord_flip() +
      scale_fill_viridis_c() +
      labs(
        title = paste("Top KEGG Pathways -", section_name),
        x = "KEGG Pathway",
        y = "-log10(adjusted p-value)",
        fill = "Gene Count"
      ) +
      theme_minimal() +
      theme(axis.text.y = element_text(size = 10))
    
    plots$kegg_plot <- kegg_plot
  }
  
  return(plots)
}
```

### Plotting

```{r}

# Define treatment order and color palette
treatment_order <- c(
  "A- T- P-",  # Control
  "A- T- P+",  # Parasite
  "A+ T- P-",  # Antibiotics
  "A+ T- P+",  # Antibiotics_Parasite
  "A- T+ P-",  # Temperature
  "A- T+ P+",  # Temperature_Parasite
  "A+ T+ P-",  # Antibiotics_Temperature
  "A+ T+ P+"   # Antibiotics_Temperature_Parasite
)

# Custom color palette matching treatment order
treatment_colors <- c(
  "#1B9E77",  # A- T- P- (Control)
  "#D95F02",  # A- T- P+ (Parasite)
  "#7570B3",  # A+ T- P- (Antibiotics)
  "#E7298A",  # A+ T- P+ (Antibiotics_Parasite)
  "#66A61E",  # A- T+ P- (Temperature)
  "#E6AB02",  # A- T+ P+ (Temperature_Parasite)
  "#A6761D",  # A+ T+ P- (Antibiotics_Temperature)
  "#666666"   # A+ T+ P+ (Antibiotics_Temperature_Parasite)
)

# Create named vector for color scale
treatment_color_scale <- setNames(treatment_colors, treatment_order)

```

### Data Import Verification

```{r data_import_check, message=FALSE, warning=FALSE}
# List of all required files
required_files <- c(
  here::here("Code", "Analysis", "DiffExpGene", "Results", "All_Treatments__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffAbund", "Results", "All_60DPE__TREATMENT__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffExpGene", "Results", "Parasite_Effect__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffAbund", "Results", "ParasiteExp_60DPE__TREATMENT__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffExpGene", "Results", "Historical_Contingency__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffAbund", "Results", "PriorStressParaExp_60DPE__TREATMENT__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffExpGene", "Results", "Recovery_Analysis__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffAbund", "Results", "PriorStressNoParaExp_60DPE__TREATMENT__significant_results.tsv"),
  here::here("Code", "Analysis", "DiffExpGene", "Results", "normalized_counts.tsv"),
  here::here("Code", "Analysis", "DiffExpGene", "Results", "sample_metadata.tsv")
)

# Check for file existence
missing_files <- required_files[!file.exists(required_files)]
if (length(missing_files) > 0) {
  warning("The following required files are missing:\n", paste(missing_files, collapse = "\n"))
} else {
  cat("All required files are present.\n")
}

# Check if phyloseq object exists
if (!exists("ps.cleaned")) {
  warning("Phyloseq object 'ps.cleaned' is not available. Please ensure it is loaded.")
} else {
  cat("Phyloseq object 'ps.cleaned' is available.\n")
  cat("Number of samples in phyloseq:", nsamples(ps.cleaned), "\n")
  cat("Number of taxa in phyloseq:", ntaxa(ps.cleaned), "\n")
}
```

```{r}

ps.tmp <- readRDS("/Users/michaelsieler/Dropbox/Mac (2)/Documents/Sharpton_Lab/Projects_Repository/Rules_of_Life/major-experiment-2023/Data/Robjects/pseq_uncleaned_05052025.rds")


ps.cleaned <-
    ps.tmp %>%
        ## Update Metadata
        ps_rename(Time = Timepoint) %>%
        microViz::ps_mutate(
            Treatment = case_when(
                Antibiotics == 0 & Temperature == 0 & Pathogen == 0 ~ "A- T- P-",
                Antibiotics == 0 & Temperature == 0 & Pathogen == 1 ~ "A- T- P+",
                Antibiotics == 1 & Temperature == 0 & Pathogen == 0 ~ "A+ T- P-",
                Antibiotics == 1 & Temperature == 0 & Pathogen == 1 ~ "A+ T- P+",
                Antibiotics == 0 & Temperature == 1 & Pathogen == 0 ~ "A- T+ P-",
                Antibiotics == 0 & Temperature == 1 & Pathogen == 1 ~ "A- T+ P+",
                Antibiotics == 1 & Temperature == 1 & Pathogen == 0 ~ "A+ T+ P-",
                Antibiotics == 1 & Temperature == 1 & Pathogen == 1 ~ "A+ T+ P+",
                TRUE ~ "Unknown"
            ), .after = "Pathogen"
        ) %>%
        microViz::ps_mutate(Sample = fecal.sample.number, .before = 1) %>%
        microViz::ps_mutate(Sample = gsub("^f", "", Sample)) %>%
        microViz::ps_filter(Treatment != "Unknown") %>%
        microViz::ps_mutate(
            History = case_when(
                Antibiotics + Temperature == 0 ~ 0,
                Antibiotics + Temperature == 1 ~ 1,
                Antibiotics + Temperature == 2 ~ 2,
            ), .after = "Treatment"
        ) %>%
        
        ## Additional metadata updates, factorizing metadata
        microViz::ps_mutate(
        # Create treatment code
            treatment_code = case_when(
              Antibiotics == 0 & Temperature == 0 & Pathogen == 0 ~ "Aneg_Tneg_Pneg",
              Antibiotics == 0 & Temperature == 0 & Pathogen == 1 ~ "Aneg_Tneg_Ppos",
              Antibiotics == 1 & Temperature == 0 & Pathogen == 0 ~ "Apos_Tneg_Pneg",
              Antibiotics == 1 & Temperature == 0 & Pathogen == 1 ~ "Apos_Tneg_Ppos",
              Antibiotics == 0 & Temperature == 1 & Pathogen == 0 ~ "Aneg_Tpos_Pneg",
              Antibiotics == 0 & Temperature == 1 & Pathogen == 1 ~ "Aneg_Tpos_Ppos",
              Antibiotics == 1 & Temperature == 1 & Pathogen == 0 ~ "Apos_Tpos_Pneg",
              Antibiotics == 1 & Temperature == 1 & Pathogen == 1 ~ "Apos_Tpos_Ppos"
            ),
            # Create treatment group factor
            treatment_group = case_when(
              Antibiotics == 0 & Temperature == 0 & Pathogen == 1 ~ "Parasite",
              Antibiotics == 1 & Temperature == 0 & Pathogen == 0 ~ "Antibiotics",
              Antibiotics == 1 & Temperature == 0 & Pathogen == 1 ~ "Antibiotics_Parasite",
              Antibiotics == 0 & Temperature == 1 & Pathogen == 0 ~ "Temperature",
              Antibiotics == 0 & Temperature == 1 & Pathogen == 1 ~ "Temperature_Parasite",
              Antibiotics == 1 & Temperature == 1 & Pathogen == 0 ~ "Antibiotics_Temperature",
              Antibiotics == 1 & Temperature == 1 & Pathogen == 1 ~ "Antibiotics_Temperature_Parasite",
              TRUE ~ "Control"
            ),
            # Convert to factor with appropriate levels
            treatment_group = factor(treatment_group, 
                                   levels = c("Control", "Parasite", 
                                              "Antibiotics", "Antibiotics_Parasite",
                                              "Temperature", "Temperature_Parasite",
                                            "Antibiotics_Temperature", "Antibiotics_Temperature_Parasite")
                                   ),
            treatment_code = factor(treatment_code, levels = treatment_order),
            # Create time point factor
            time_point = factor(Time, levels = c(0, 14, 18, 25, 29, 60)),
            # Create pathogen status factor
            pathogen_status = factor(ifelse(Pathogen == 1, "Exposed", "Unexposed"),
                                   levels = c("Unexposed", "Exposed")),
            # Create sex factor
            sex = factor(Sex, levels = c("M", "F"))
            )  %>%
    microViz::ps_mutate(Treatment = factor(Treatment, levels = treatment_order)) %>%
      microViz::ps_mutate(Exp_Type = case_when(
          Treatment %in% c("A- T- P-", "A- T- P+")  ~ "No prior stressor(s)",
          Treatment %in% c("A+ T- P-", "A+ T- P+")  ~ "Antibiotics",
          Treatment %in% c("A- T+ P-", "A- T+ P+") ~ "Temperature",
          Treatment %in% c("A+ T+ P-", "A+ T+ P+") ~ "Combined",
      )) %>%
      microViz::ps_mutate(Exp_Type = factor(Exp_Type, levels = c("No prior stressor(s)", "Antibiotics", "Temperature", "Combined"))) %>%
  # Fix names for taxonomic ranks not identified
  microViz::tax_fix(suffix_rank = "current", anon_unique = T, unknown = NA) %>% 
  # Filter for any samples that contain more than 5000 reads
  microViz::ps_filter(sample_sums(.) > 5000) %>%
  # Any taxa not found in at least 3 samples are removed
  microViz::tax_filter(min_prevalence = 3, undetected = 0) %>%
  # Remove any unwanted reads
  microViz::tax_select(c("Mitochondria", "Chloroplast", "Eukaryota"), deselect = TRUE) %>%
  microViz::tax_select(c("Bacteria, Phylum"), deselect = TRUE) 


# ps.cleaned %>% microViz::samdat_tbl()

```

## 00) All {.tabset}

### Data Import & Filtering

```{r import_all, message=FALSE, warning=FALSE}
# Set seed for reproducibility
set.seed(42)

# Import DEGs (All treatments)
deg_file <- here::here("Code", "Analysis", "DiffExpGene", "Results", "All_Treatments__significant_results.tsv")
deg_all <- readr::read_tsv(deg_file)

# Import DATs (All treatments)
dat_file <- here::here("Code", "Analysis", "DiffAbund", "Results", "All_60DPE__TREATMENT__significant_results.tsv")
dat_all <- readr::read_tsv(dat_file)

# Filter for significant DEGs and DATs (adjust threshold as needed)
deg_sig <- deg_all %>%
  dplyr::filter(padj < 0.05)

dat_sig <- dat_all %>%
  dplyr::filter(qval < 0.05)

# Print summary
cat("\nNumber of significant DEGs:", nrow(deg_sig), "\n")
cat("Number of significant DATs:", nrow(dat_sig), "\n")
```

### Prepare for Correlation Analysis

```{r prep_correlation_all}
# Prepare data for correlation analysis
cor_data_all <- prepare_correlation_data(
  deg_sig = deg_all, 
  dat_sig = dat_all,
  treatments = c("A- T- P-", "A- T- P+", "A+ T- P-", "A+ T- P+", 
                 "A- T+ P-", "A- T+ P+", "A+ T+ P-", "A+ T+ P+"),
  ps_object = ps.cleaned
)
```

### Simple Correlation Analysis

```{r simple_correlation_all, message=FALSE, warning=FALSE}
# --- Simple Correlation Analysis using modular functions ---

# Calculate simple correlations
cor_results_all <- calculate_simple_correlations(cor_data_all$cor_input)

# Print summary
print_correlation_summary(cor_results_all, section_name = "All Treatments")

# Create plots
cor_plots_all <- plot_correlation_summary(cor_results_all, section_name = "All Treatments")
cor_plots_all$simple_cor
```

### Partial Correlation Analysis

```{r partial_correlation_all, message=FALSE, warning=FALSE}
# --- Partial Correlation Analysis using modular functions ---

# Calculate partial correlations
partial_cor_results_all <- calculate_partial_correlations(
  cor_data_all$cor_input_cov, 
  top_n = 50
)

# Print summary
print_correlation_summary(cor_results_all, partial_cor_results_all, "All Treatments")

# Create plots
cor_plots_all <- plot_correlation_summary(
  cor_results_all, 
  partial_cor_results_all, 
  "All Treatments"
)
cor_plots_all$partial_cor
```

### Correlation & Network Analysis

```{r correlation_network_all}
# Create bipartite network visualization
network_all <- create_bipartite_network(
  cor_results_all, 
  partial_cor_results_all,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  max_edges = 50,
  section_name = "All Treatments"
)

# Display network plot
if (!is.null(network_all)) {
  network_all$plot
  
  # Print network summary
  cat("\nNetwork Summary:\n")
  cat("Number of genes:", network_all$n_genes, "\n")
  cat("Number of taxa:", network_all$n_taxa, "\n")
  cat("Number of edges:", network_all$n_edges, "\n")
}
```

### Functional Enrichment

```{r enrichment_all}
# Run comprehensive functional enrichment analysis
enrichment_all <- run_functional_enrichment(
  cor_results_all,
  partial_cor_results_all,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  section_name = "All Treatments"
)

# Create enrichment plots
if (!is.null(enrichment_all)) {
  enrichment_plots_all <- plot_enrichment_results(enrichment_all, "All Treatments")
  
  # Display GO enrichment plot
  if (!is.null(enrichment_plots_all$go_plot)) {
    enrichment_plots_all$go_plot
  }
  
  # Display KEGG enrichment plot
  if (!is.null(enrichment_plots_all$kegg_plot)) {
    enrichment_plots_all$kegg_plot
  }
  
  # Print summary
  cat("\n=== Functional Enrichment Summary - All Treatments ===\n")
  cat("Number of correlated genes:", enrichment_all$n_genes, "\n")
  cat("Number of genes mapped to Entrez IDs:", enrichment_all$n_entrez, "\n")
  
  if (!is.null(enrichment_all$go_results)) {
    cat("Number of significant GO terms:", nrow(enrichment_all$go_results), "\n")
  }
  
  if (!is.null(enrichment_all$kegg_results)) {
    cat("Number of significant KEGG pathways:", nrow(enrichment_all$kegg_results), "\n")
  }
}
```


## 01) What is the host-microbiome response to parasite exposure? {.tabset}

### Data Import & Filtering

```{r import_parasite, message=FALSE, warning=FALSE}
set.seed(42)
# Import DEGs (Parasite effect)
deg_file_01 <- here::here("Code", "Analysis", "DiffExpGene", "Results", "Parasite_Effect__significant_results.tsv")
deg_01 <- readr::read_tsv(deg_file_01)

# Import DATs (Parasite effect)
dat_file_01 <- here::here("Code", "Analysis", "DiffAbund", "Results", "ParasiteExp_60DPE__TREATMENT__significant_results.tsv")
dat_01 <- readr::read_tsv(dat_file_01)

# Filter for significant DEGs and DATs
deg_sig_01 <- deg_01 %>% dplyr::filter(padj < 0.05)
dat_sig_01 <- dat_01 %>% dplyr::filter(qval < 0.05)

cat("\nNumber of significant DEGs:", nrow(deg_sig_01), "\n")
cat("Number of significant DATs:", nrow(dat_sig_01), "\n")
```

### Prepare for Correlation Analysis

```{r prep_correlation_01}
# --- Correlation Analysis using modular functions ---

# Prepare data
cor_data_parasite <- prepare_correlation_data(
  deg_sig = deg_01, 
  dat_sig = dat_01,
  treatments = c("A- T- P-", "A- T- P+")
)

# Calculate simple correlations
cor_results_01 <- calculate_simple_correlations(cor_data_parasite$cor_input)

# Calculate partial correlations
partial_cor_results_01 <- calculate_partial_correlations(
  cor_data_parasite$cor_input_cov, 
  top_n = 50
)

# Print summary
print_correlation_summary(cor_results_01, partial_cor_results_01, "Parasite Exposure")

# Create plots
cor_plots_01 <- plot_correlation_summary(
  cor_results_01, 
  partial_cor_results_01, 
  "Parasite Exposure"
)
cor_plots_01$simple_cor
cor_plots_01$partial_cor
```

### Correlation & Network Analysis

```{r correlation_network_01}
# Create bipartite network visualization
network_01 <- create_bipartite_network(
  cor_results_01, 
  partial_cor_results_01,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  max_edges = 50,
  section_name = "Parasite Exposure"
)

# Display network plot
if (!is.null(network_01)) {
  network_01$plot
  
  # Print network summary
  cat("\nNetwork Summary:\n")
  cat("Number of genes:", network_01$n_genes, "\n")
  cat("Number of taxa:", network_01$n_taxa, "\n")
  cat("Number of edges:", network_01$n_edges, "\n")
}
```

### Functional Enrichment

```{r enrichment_01}
# Run comprehensive functional enrichment analysis
enrichment_01 <- run_functional_enrichment(
  cor_results_01,
  partial_cor_results_01,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  section_name = "Parasite Exposure"
)

# Create enrichment plots
if (!is.null(enrichment_01)) {
  enrichment_plots_01 <- plot_enrichment_results(enrichment_01, "Parasite Exposure")
  
  # Display GO enrichment plot
  if (!is.null(enrichment_plots_01$go_plot)) {
    enrichment_plots_01$go_plot
  }
  
  # Display KEGG enrichment plot
  if (!is.null(enrichment_plots_01$kegg_plot)) {
    enrichment_plots_01$kegg_plot
  }
  
  # Print summary
  cat("\n=== Functional Enrichment Summary - Parasite Exposure ===\n")
  cat("Number of correlated genes:", enrichment_01$n_genes, "\n")
  cat("Number of genes mapped to Entrez IDs:", enrichment_01$n_entrez, "\n")
  
  if (!is.null(enrichment_01$go_results)) {
    cat("Number of significant GO terms:", nrow(enrichment_01$go_results), "\n")
  }
  
  if (!is.null(enrichment_01$kegg_results)) {
    cat("Number of significant KEGG pathways:", nrow(enrichment_01$kegg_results), "\n")
  }
}
```


## 02) Is the host-microbiome response to parasite exposure historically contingent? {.tabset}

### Data Import & Filtering

```{r import_histcont, message=FALSE, warning=FALSE}
set.seed(42)
# Import DEGs (Historical contingency)
deg_file_02 <- here::here("Code", "Analysis", "DiffExpGene", "Results", "Historical_Contingency__significant_results.tsv")
deg_02 <- readr::read_tsv(deg_file_02)

# Import DATs (Historical contingency)
dat_file_02 <- here::here("Code", "Analysis", "DiffAbund", "Results", "PriorStressParaExp_60DPE__TREATMENT__significant_results.tsv")
dat_02 <- readr::read_tsv(dat_file_02)

# Filter for significant DEGs and DATs
deg_sig_02 <- deg_02 %>% dplyr::filter(padj < 0.05)
dat_sig_02 <- dat_02 %>% dplyr::filter(qval < 0.05)

cat("\nNumber of significant DEGs:", nrow(deg_sig_02), "\n")
cat("Number of significant DATs:", nrow(dat_sig_02), "\n")
```

### Prepare for Correlation Analysis

```{r prep_correlation_02}
# --- Correlation Analysis using modular functions ---

# Prepare data
cor_data_historical <- prepare_correlation_data(
  deg_sig = deg_02, 
  dat_sig = dat_02,
  treatments = c("A+ T- P-", "A+ T- P+", "A- T+ P-", "A- T+ P+", "A+ T+ P-", "A+ T+ P+")
)

# Calculate simple correlations
cor_results_02 <- calculate_simple_correlations(cor_data_historical$cor_input)

# Calculate partial correlations
partial_cor_results_02 <- calculate_partial_correlations(
  cor_data_historical$cor_input_cov, 
  top_n = 50
)

# Print summary
print_correlation_summary(cor_results_02, partial_cor_results_02, "Historical Contingency")

# Create plots
cor_plots_02 <- plot_correlation_summary(
  cor_results_02, 
  partial_cor_results_02, 
  "Historical Contingency"
)
cor_plots_02$simple_cor
cor_plots_02$partial_cor
```

### Correlation & Network Analysis

```{r correlation_network_02}
# Create bipartite network visualization
network_02 <- create_bipartite_network(
  cor_results_02, 
  partial_cor_results_02,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  max_edges = 50,
  section_name = "Historical Contingency"
)

# Display network plot
if (!is.null(network_02)) {
  network_02$plot
  
  # Print network summary
  cat("\nNetwork Summary:\n")
  cat("Number of genes:", network_02$n_genes, "\n")
  cat("Number of taxa:", network_02$n_taxa, "\n")
  cat("Number of edges:", network_02$n_edges, "\n")
}
```

### Functional Enrichment

```{r enrichment_02}
# Run comprehensive functional enrichment analysis
enrichment_02 <- run_functional_enrichment(
  cor_results_02,
  partial_cor_results_02,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  section_name = "Historical Contingency"
)

# Create enrichment plots
if (!is.null(enrichment_02)) {
  enrichment_plots_02 <- plot_enrichment_results(enrichment_02, "Historical Contingency")
  
  # Display GO enrichment plot
  if (!is.null(enrichment_plots_02$go_plot)) {
    enrichment_plots_02$go_plot
  }
  
  # Display KEGG enrichment plot
  if (!is.null(enrichment_plots_02$kegg_plot)) {
    enrichment_plots_02$kegg_plot
  }
  
  # Print summary
  cat("\n=== Functional Enrichment Summary - Historical Contingency ===\n")
  cat("Number of correlated genes:", enrichment_02$n_genes, "\n")
  cat("Number of genes mapped to Entrez IDs:", enrichment_02$n_entrez, "\n")
  
  if (!is.null(enrichment_02$go_results)) {
    cat("Number of significant GO terms:", nrow(enrichment_02$go_results), "\n")
  }
  
  if (!is.null(enrichment_02$kegg_results)) {
    cat("Number of significant KEGG pathways:", nrow(enrichment_02$kegg_results), "\n")
  }
}
```


## 03) Is the host-microbiome recovery historically contingent? {.tabset}

### Data Import & Filtering

```{r import_recovery, message=FALSE, warning=FALSE}
set.seed(42)
# Import DEGs (Recovery analysis)
deg_file_03 <- here::here("Code", "Analysis", "DiffExpGene", "Results", "Recovery_Analysis__significant_results.tsv")
deg_03 <- readr::read_tsv(deg_file_03)

# Import DATs (Recovery analysis)
dat_file_03 <- here::here("Code", "Analysis", "DiffAbund", "Results", "PriorStressNoParaExp_60DPE__TREATMENT__significant_results.tsv")
dat_03 <- readr::read_tsv(dat_file_03)

# Filter for significant DEGs and DATs
deg_sig_03 <- deg_03 %>% dplyr::filter(padj < 0.05)
dat_sig_03 <- dat_03 %>% dplyr::filter(qval < 0.05)

cat("\nNumber of significant DEGs:", nrow(deg_sig_03), "\n")
cat("Number of significant DATs:", nrow(dat_sig_03), "\n")
```

### Prepare for Correlation Analysis

```{r prep_correlation_03}
# --- Correlation Analysis using modular functions ---

# Prepare data for correlation analysis
cor_data_recovery <- prepare_correlation_data(
  deg_sig = deg_03, 
  dat_sig = dat_03,
  treatments = c("A- T- P-", "A+ T- P-", "A- T+ P-", "A+ T+ P-")
)

# Calculate simple correlations
cor_results_03 <- calculate_simple_correlations(cor_data_recovery$cor_input)

# Calculate partial correlations
partial_cor_results_03 <- calculate_partial_correlations(
  cor_data_recovery$cor_input_cov, 
  top_n = 50
)

# Print summary
print_correlation_summary(cor_results_03, partial_cor_results_03, "Recovery Analysis")

# Create plots
cor_plots_03 <- plot_correlation_summary(
  cor_results_03, 
  partial_cor_results_03, 
  "Recovery Analysis"
)
cor_plots_03$simple_cor
cor_plots_03$partial_cor
```

### Correlation & Network Analysis

```{r correlation_network_03}
# Create bipartite network visualization
network_03 <- create_bipartite_network(
  cor_results_03, 
  partial_cor_results_03,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  max_edges = 50,
  section_name = "Recovery Analysis"
)

# Display network plot
if (!is.null(network_03)) {
  network_03$plot
  
  # Print network summary
  cat("\nNetwork Summary:\n")
  cat("Number of genes:", network_03$n_genes, "\n")
  cat("Number of taxa:", network_03$n_taxa, "\n")
  cat("Number of edges:", network_03$n_edges, "\n")
}
```

### Functional Enrichment

```{r enrichment_03}
# Run comprehensive functional enrichment analysis
enrichment_03 <- run_functional_enrichment(
  cor_results_03,
  partial_cor_results_03,
  cor_threshold = 0.5,
  p_threshold = 0.05,
  section_name = "Recovery Analysis"
)

# Create enrichment plots
if (!is.null(enrichment_03)) {
  enrichment_plots_03 <- plot_enrichment_results(enrichment_03, "Recovery Analysis")
  
  # Display GO enrichment plot
  if (!is.null(enrichment_plots_03$go_plot)) {
    enrichment_plots_03$go_plot
  }
  
  # Display KEGG enrichment plot
  if (!is.null(enrichment_plots_03$kegg_plot)) {
    enrichment_plots_03$kegg_plot
  }
  
  # Print summary
  cat("\n=== Functional Enrichment Summary - Recovery Analysis ===\n")
  cat("Number of correlated genes:", enrichment_03$n_genes, "\n")
  cat("Number of genes mapped to Entrez IDs:", enrichment_03$n_entrez, "\n")
  
  if (!is.null(enrichment_03$go_results)) {
    cat("Number of significant GO terms:", nrow(enrichment_03$go_results), "\n")
  }
  
  if (!is.null(enrichment_03$kegg_results)) {
    cat("Number of significant KEGG pathways:", nrow(enrichment_03$kegg_results), "\n")
  }
}
```



